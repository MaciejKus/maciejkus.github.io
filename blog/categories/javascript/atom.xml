<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript, | Maciej Kus is not a Figure Skater]]></title>
  <link href="http://maciejkus.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://maciejkus.com/"/>
  <updated>2014-12-07T15:04:05-08:00</updated>
  <id>http://maciejkus.com/</id>
  <author>
    <name><![CDATA[Maciej Kus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Removing Event Listeners When Redrawing Canvas]]></title>
    <link href="http://maciejkus.com/blog/2014/09/28/removing-event-listeners-when-redrawing-canvas/"/>
    <updated>2014-09-28T15:43:08-07:00</updated>
    <id>http://maciejkus.com/blog/2014/09/28/removing-event-listeners-when-redrawing-canvas</id>
    <content type="html"><![CDATA[<p>I was drawing a network graph using canvas, it had nodes and edges and when a user clicks on a node the canvas is redrawn. All of this is fine, but then I also wanted to have a navigation bar outside of the canvas which would redraw the canvas when that was clicked. Now redrawing the canvas is easy, but the redraw did not remove the event listeners from the previously drawn canvas. For example, say a node moves to the middle of the graph if it is clicked on. Even if the canvas is redrawn with that node gone, the event listener stayed around and when the user clicked on the section of the canvas where the node used to be, the event would still trigger and the node would be drawn in the middle of the graph. </p>


<!--more-->


<p>The problem came about because the navigation bar was outside of the scope of the canvas function. Even if I turned 'canvas' into a global variable, 'canvas.removeEventListener' did not work because the event handler was not a global variable. I could eventually moved enough of the variables into the global scope that maybe things would have worked. 'removeEventListener' worked fine when I used it inside the canvas function. But luckily the page was already using jQuery, so after playing around and giving up on 'removeEventListener', I moved on to use the jQuery 'on()' and 'off()' event handler functions. </p>


<p>The reason these worked so well is that using 'off()' without any arguments removes all event handlers which were added using the 'on()' function. You cannot mix 'addEventListener' and 'off()' together. But anything attached with a 'on()' was fair game. So all I needed to add to the sidebar was '$(canvas).off();' and any event listener attached to the canvas element was removed.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dragging and Switching Images with JavaScript]]></title>
    <link href="http://maciejkus.com/blog/2014/09/21/dragging-and-switching-images-with-javascript/"/>
    <updated>2014-09-21T15:46:14-07:00</updated>
    <id>http://maciejkus.com/blog/2014/09/21/dragging-and-switching-images-with-javascript</id>
    <content type="html"><![CDATA[<p>I needed a simple mechanism to drag and drop images from one place to another on a webpage. Using the HTML5 draggable, ondragstart and ondragover events I made a simple script which allows the user to drag an image, and then drop that image onto another image. The two images then switch positions on the page. The HTML code for each image looks something like this:
{% codeblock %}
<img src="imageSource.png" draggable="true" ondragstart="return dragStart(event)" ondragover="return dragOver(event)" ondrop="dragDrop(event)">
{% endcodeblock %}
draggable allows the image to be dragged. This is the default for most browsers when it comes to images, but it cannot hurt to explicitly set it.<br>
ondragstart is triggered when the dragging starts.<br>
ondragover is similar to a mouseover event. It is fired when the mouse is over the event.<br>
ondrop is fired when the mouse button is finally released.
The JavaScript looks like this:</p>


<!-- more -->


<p>
{% codeblock lang:javascript %}
var dragSrc = null; //used to store the dropped object

function dragStart(ev) {
    ev.dataTransfer.effectAllowed='move'; //allows the object to be moved
    dragSrc = ev.target; //sets the dragged object to be dragSrc
    return true;
}

function dragOver(e) {
    if (e.preventDefault) { //stop default browser action
        e.preventDefault(); // Allows us to drop.
    }
    return false;
}

function dragDrop(ev) {
    ev.preventDefault(); //stops default browser action
    if (dragSrc != ev.target) { //only if dropping onto another image, not self
        var x = dragSrc.outerHTML; //temp variable
        dragSrc.outerHTML = ev.target.outerHTML; //sets dragged object to current image
        ev.target.outerHTML = x; //set current image to dragged image
    }
    return false;
}
{% endcodeblock %}
</p>


<p>
This code should work for any kind of HTML, not only a img tag. You can see working demo of this at this <a href='http://subnettingpractice.com/ethernet_wiring.html'>Ethernet wire ordering</a> page. The JavaScript on that page is minified to make it load slightly faster, but you can see what the above is doing.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple HTML5 Games]]></title>
    <link href="http://maciejkus.com/blog/2014/08/04/simple-html5-games/"/>
    <updated>2014-08-04T10:39:21-07:00</updated>
    <id>http://maciejkus.com/blog/2014/08/04/simple-html5-games</id>
    <content type="html"><![CDATA[<p>
A while ago I wanted to work with graphics. Before then all I have ever coded were text based programs. Calculators, problem generators, text games, console scripts, etc. I figured a game would be the best way to do this and that HTML5/canvas would be the best area to learn. Internet browsers have largely adopted canvas and it works on all kinds of devices, including smart phones. I hope posting these early experiments will allow others to speed up their own learning of HTML5/canvas. 
</p>


<p>A coworker suggested I start with making a breakout style game and then move on to pong. My first step was to actually learn how to draw a <a href='../../../../../html5-games/ball_shadow.html'>circle</a>. Then how to move the circle. Once I got that down the rest was easy.
</p>


<!-- more -->


<p>OK, maybe not easy, but there is enough documentation out there that I was able to make  some simple graphical programs. Rather than dive right into breakout I made a little 'game' where balls simply bounce around in two 'rooms'. This was largely a way to practice collision detection and collision response before making a more advanced game. The result can be played <a href='../../../../../html5-games/click-balls.html'>here</a>. The collision response in the game is definitely lacking, but it worked well enough for me to feel like I understood how things should work.
</p>


<p>
After that I felt like I understood collisions well enough that I did not need to make a breakout game and instead could move straight to a pong game, which is what I did. Instead of regular pong I made it more of a wall-ball style game where both players are on the same side. It's pretty much pong, with a tiny difference. See it in action <a href='../../../../../html5-games/wallball.html'>here</a>.
</p>


<p>
Finally, I wanted something more advanced, so I made a space shooter game. Instead of trying to use sprites I just used basic canvas shapes like circles, but the idea works pretty well. Play it <a href='../../../../../html5-games/shooter.html'>here</a>.
</p>


<p>
The above three were all learning experiences, and I believe I could go through the code and make it a bit nicer and maybe more efficient today. I am posting them as I originally wrote them. No improvments or anything, but I found that looking at how other simple games were coded was very helpful. Hopefully looking at the page source for the above might be helpful for others who are starting out. 
</p>

]]></content>
  </entry>
  
</feed>
