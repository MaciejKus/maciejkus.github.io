<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: canvas | Maciej Kus is not a Figure Skater]]></title>
  <link href="http://maciejkus.com/blog/categories/canvas/atom.xml" rel="self"/>
  <link href="http://maciejkus.com/"/>
  <updated>2015-10-11T15:57:19-07:00</updated>
  <id>http://maciejkus.com/</id>
  <author>
    <name><![CDATA[Maciej Kus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Canvas Match 3 Game]]></title>
    <link href="http://maciejkus.com/blog/2015/09/29/canvas-match-3-game/"/>
    <updated>2015-09-29T09:39:45-07:00</updated>
    <id>http://maciejkus.com/blog/2015/09/29/canvas-match-3-game</id>
    <content type="html"><![CDATA[<p>I decided to make a match three game as a first step to learning a new game engine. Since Enchant.js is pretty much abandoned at this point, I figured it was time to try something new, and I decided on Phaser.js. So I start making the game, but it just seems that using a game engine was overkill for something as simple as a match-three game.</p>

<p>So I decided to save learning Phaser.js for a different project and just make the match-three game using plain old vanilla JavaScript and the html5 canvas element. Play it <a href='http://brogress.smoothiegains.com/smoothie_match/'>here</a>.</p>

<!-- more -->


<p>The coolest thing about making the game was dealing with all the animations. I split up the animations to only render the tile which is moving, instead of rendering the whole canvas every time something has to be changed. This saves a lot of resources, making the game run faster and smoother. The trick was to make sure that things didn&rsquo;t overlap.  The animations run asynchronously, so I had to avoid situations where multiple animations were running on top of one another, or that the logic from a running animation did not interfere with the logic of a new mouse click.</p>

<p>The game is pretty basic, but I was able to remove all the little glitches I came across when testing. I&rsquo;m also pleased to have made a game where the graphics actually look OK. This is all thanks to finding creative commons images and playing with GIMP a little bit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[unit-vector-eyes-follow-mouse]]></title>
    <link href="http://maciejkus.com/blog/2015/06/23/unit-vector-eyes-follow-mouse/"/>
    <updated>2015-06-23T17:11:11-07:00</updated>
    <id>http://maciejkus.com/blog/2015/06/23/unit-vector-eyes-follow-mouse</id>
    <content type="html"><![CDATA[<p>A unit vector or normal vector is useful for pointing things at other things. Like pointing eyes at a mouse. See here what a unit vector is:
<a href="https://en.wikipedia.org/wiki/Unit_vector">https://en.wikipedia.org/wiki/Unit_vector</a></p>

<p>and then check out <a href="http://maciejkus.com/unit-vector-eyes/">http://maciejkus.com/unit-vector-eyes/</a> to see some html5/canvas eyes which follow your mouse cursor. They currently only follow the mouse when it is inside the canvas element, but this can easily be changed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[box_whiskers_calc]]></title>
    <link href="http://maciejkus.com/blog/2015/06/20/box-whiskers-calc/"/>
    <updated>2015-06-20T12:30:32-07:00</updated>
    <id>http://maciejkus.com/blog/2015/06/20/box-whiskers-calc</id>
    <content type="html"><![CDATA[<p> There is a shocking lack of box and whisker graph calculators on the Internet. Well, accurate ones anyway, so I made one. Originally I needed one for some calculations I was doing and made one in Python, but then I figured I can easily rewrite it into Javascript and make it available for others. I even added a simple HTML5 canvas graph. You can find it at <a href="http://maciejkus.com/box_whiskers/">Box and Whiskers Calculator</a></p>
]]></content>
  </entry>
  
</feed>
